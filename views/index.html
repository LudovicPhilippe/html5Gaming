<html>
<head>
    <title>Exo 3D #1</title>
    <!--<style>canvas { width: 100%; height: 100%; background-color: black; }</style>-->
</head>
<body>
<!-- <script src="/js/three/build/three.js"></script> -->
<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
<script src="js/three/examples/js/controls/FlyControls.js"></script>
<!--
<script src="../src/extras/core/Curve.js"></script>
<script src="../src/extras/geometries/TubeGeometry.js"></script>
<script src="../src/extras/helpers/CameraHelper.js"></script>
-->

<!-- where curves formulas are defined -->
<script src="js/three/examples/js/CurveExtras.js"></script>

<script src="js/three/examples/js/libs/stats.min.js"></script>
<script>
/*
 var scene = new THREE.Scene(),
 camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000),
 renderer = new THREE.WebGLRenderer(),
 mouseX = 0,
 mouseY = 0;
 renderer.setSize( window.innerWidth, window.innerHeight );
 document.body.appendChild( renderer.domElement );

 var //geometry = new THREE.SphereGeometry(25,64,64),
 //geometry1 = new THREE.SphereGeometry(50,64,64),
 geometry = new THREE.CubeGeometry(50,50,50),
 geometry1 = new THREE.CubeGeometry(100,100,100),
 material = new THREE.MeshLambertMaterial({
 color: 0xff0000,
 ambient: 0xA00000
 }),
 sphere = new THREE.Mesh( geometry, material),
 sphere1 = new THREE.Mesh( geometry1, material);
 var clock = new THREE.Clock();


 controls = new THREE.FlyControls( camera );

 controls.movementSpeed = 0;
 controls.domElement = renderer.domElement;
 controls.rollSpeed = Math.PI / 8;
 controls.autoForward = false;
 controls.dragToLook = false;

 sphere1.position.x = 190;

 var light = new THREE.AmbientLight( 0x404040 ); // soft white light
 scene.add( light );

 scene.add(sphere);
 sphere.add(sphere1);

 var pointLight = new THREE.PointLight( 0xffffff, 1, 300000);
 pointLight.position.set( 0, 190, 0 );

 sphere1.add( pointLight );
 camera.lookAt( sphere.position );


 /*
 document.addEventListener( 'mousemove', onDocumentMouseMove, false );
 function onDocumentMouseMove( event ) {

 event.preventDefault();
 //mouseX = ( event.clientX - window.innerWidth/2 );
 //mouseY = ( event.clientY - window.innerHeight/2 );
 //camera.lookAt(new THREE.Vector3(mouseX,mouseY,0));
 }
 */
/*

 function checkKey(e) {

 e = e || window.event;

 if (e.keyCode == '38') {
 // up arrow
 camera.position.y += 0.5;
 }
 else if (e.keyCode == '40') {
 // down arrow
 camera.position.y -= 0.5;
 }

 else if (e.keyCode == '83') {
 // s
 camera.position.z += 2;
 }
 else if (e.keyCode == '87') {
 // w
 camera.position.z -= 2;
 }

 else if (e.keyCode == '65') {
 // a
 camera.position.x -= 2;
 }
 else if (e.keyCode == '68') {
 // d
 camera.position.x += 2;
 }
 }

 camera.position.z = 300;
 document.onkeydown = checkKey;


 var rotationSpeed = (2.0 * Math.PI) / 4.0;

 function render() {
 // elapsedtime
 var delta = clock.getDelta();

 // Update scene
 sphere.rotation.y += rotationSpeed * delta;
 sphere1.rotation.x += rotationSpeed * delta;

 controls.update( delta );

 // render scene
 renderer.render(scene, camera);
 requestAnimationFrame(render);
 }

 render();
 */

var container, stats;

var camera, scene, renderer, splineCamera, cameraHelper, cameraEye;

var text, plane;

var targetRotation = 0;
var targetRotationOnMouseDown = 0;

var mouseX = 0;
var mouseXOnMouseDown = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var binormal = new THREE.Vector3();
var normal = new THREE.Vector3();


var pipeSpline = new THREE.SplineCurve3([
    new THREE.Vector3(0, 10, -10), new THREE.Vector3(10, 0, -10), new THREE.Vector3(20, 0, 0), new THREE.Vector3(30, 0, 10), new THREE.Vector3(30, 0, 20), new THREE.Vector3(20, 0, 30), new THREE.Vector3(10, 0, 30), new THREE.Vector3(0, 0, 30), new THREE.Vector3(-10, 10, 30), new THREE.Vector3(-10, 20, 30), new THREE.Vector3(0, 30, 30), new THREE.Vector3(10, 30, 30), new THREE.Vector3(20, 30, 15), new THREE.Vector3(10, 30, 10), new THREE.Vector3(0, 30, 10), new THREE.Vector3(-10, 20, 10), new THREE.Vector3(-10, 10, 10), new THREE.Vector3(0, 0, 10), new THREE.Vector3(10, -10, 10), new THREE.Vector3(20, -15, 10), new THREE.Vector3(30, -15, 10), new THREE.Vector3(40, -15, 10), new THREE.Vector3(50, -15, 10), new THREE.Vector3(60, 0, 10), new THREE.Vector3(70, 0, 0), new THREE.Vector3(80, 0, 0), new THREE.Vector3(90, 0, 0), new THREE.Vector3(100, 0, 0)]);

var sampleClosedSpline = new THREE.ClosedSplineCurve3([
    new THREE.Vector3(0, -40, -40),
    new THREE.Vector3(0, 40, -40),
    new THREE.Vector3(0, 140, -40),
    new THREE.Vector3(0, 40, 40),
    new THREE.Vector3(0, -40, 40)
]);




// Keep a dictionary of Curve instances
var splines = {
    GrannyKnot: new THREE.Curves.GrannyKnot(),
    HeartCurve: new THREE.Curves.HeartCurve(3.5),
    VivianiCurve: new THREE.Curves.VivianiCurve(70),
    KnotCurve: new THREE.Curves.KnotCurve(),
    HelixCurve: new THREE.Curves.HelixCurve(),
    TrefoilKnot: new THREE.Curves.TrefoilKnot(),
    TorusKnot: new THREE.Curves.TorusKnot(20),
    CinquefoilKnot: new THREE.Curves.CinquefoilKnot(20),
    TrefoilPolynomialKnot: new THREE.Curves.TrefoilPolynomialKnot(14),
    FigureEightPolynomialKnot: new THREE.Curves.FigureEightPolynomialKnot(),
    DecoratedTorusKnot4a: new THREE.Curves.DecoratedTorusKnot4a(),
    DecoratedTorusKnot4b: new THREE.Curves.DecoratedTorusKnot4b(),
    DecoratedTorusKnot5a: new THREE.Curves.DecoratedTorusKnot5a(),
    DecoratedTorusKnot5c: new THREE.Curves.DecoratedTorusKnot5c(),
    PipeSpline: pipeSpline,
    SampleClosedSpline: sampleClosedSpline
};




extrudePath = new THREE.Curves.TrefoilKnot();

var dropdown = '<select id="dropdown" onchange="addTube(this.value)">';

var s;
for ( s in splines ) {
    dropdown += '<option value="' + s + '"';
    dropdown += '>' + s + '</option>';
}

dropdown += '</select>';

var closed2 = true;
var debug = true;
var parent;
var tube, tubeMesh;
var animation = false, lookAhead = false;
var scale;
var texture = THREE.ImageUtils.loadTexture('./lol.png');
var showCameraHelper = false;

function addTube() {

    //var value = new THREE.Curves.DecoratedTorusKnot5c();SampleClosedSpline
    var value = splines.SampleClosedSpline;


    var segments = 800;
    closed2 = true;
    debug = false;

    var radiusSegments = 24;

    //console.log('adding tube', value, closed2, debug, radiusSegments);
    if (tubeMesh) parent.remove(tubeMesh);

    extrudePath = value;

    tube = new THREE.TubeGeometry(extrudePath, segments, 4, radiusSegments, closed2, debug);
    addGeometry(tube, 0xff00ff);
    setScale();

}

function setScale() {

    scale = 20;
    tubeMesh.scale.set( scale, scale, scale );
}

function addGeometry( geometry, color, texture ) {

    // 3d shape

    tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [
        new THREE.MeshLambertMaterial({

            color:0xFFFFFF,
            //map: THREE.ImageUtils.loadTexture("./space6.jpg"),
            side : THREE.DoubleSide
            //color: color,
            //opacity : 1,
            //opacity: geometry.debug ? 0.2 : 0.8,
            //transparent: true
        }),
        new THREE.MeshBasicMaterial({
            color:0xFFFFFF,
            //map: THREE.ImageUtils.loadTexture("./ground_bump_3d_.jpg"),
            //color: 0x000000,
            opacity: 1,
            wireframe: true
        })]);

    if ( geometry.debug ) tubeMesh.add( geometry.debug );

    parent.add( tubeMesh );

}
animation = animation === false;
//function animateCamera( toggle ) {


//  if ( toggle ) {
//    animation = animation === false;
//document.getElementById('animation').value = 'Camera Spline Animation View: ' + (animation? 'ON': 'OFF');
//}

//lookAhead = document.getElementById('lookAhead').checked;

//showCameraHelper = document.getElementById('cameraHelper').checked;

//cameraHelper.visible = showCameraHelper;
//cameraEye.visible = showCameraHelper;
//}


init();
animate();

function init() {

    container = document.createElement('div');
    document.body.appendChild(container);
    //info.innerHTML += '<br/><br/><input id="animation" type="button" onclick="animateCamera(true)" value="Camera Spline Animation View: OFF"/><br/> Look Ahead <input id="lookAhead" type="checkbox" onchange="animateCamera()" /> Camera Helper <input id="cameraHelper" type="checkbox" onchange="animateCamera()" />';

    /*
     var info = document.createElement('div');
     info.style.position = 'absolute';
     info.style.top = '10px';
     info.style.width = '100%';
     info.style.textAlign = 'center';

     //info.innerHTML += '<input id="animation" type="button" onclick="animateCamera(true)" value="Camera Spline Animation View: OFF"/>';
     info.innerHTML += '<input id="animation" type="button" onclick="animateCamera(true)" value="Camera Spline Animation View: OFF"/>';
     container.appendChild(info);
     */
    //

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.set(0, 50, 500);

    scene = new THREE.Scene();

    var light = new THREE.DirectionalLight( 0xffffff );
    light.position.set( 0, 0, 1 );
    scene.add( light );

    parent = new THREE.Object3D();
    parent.position.y = 100;
    scene.add( parent );

    splineCamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 10000 );
    parent.add( splineCamera );

    cameraHelper = new THREE.CameraHelper( splineCamera );
    scene.add( cameraHelper );

    addTube();

    // Debug point

    cameraEye = new THREE.Mesh( new THREE.SphereGeometry( 5 ), new THREE.MeshBasicMaterial( { color: 0xdddddd } ) );
    parent.add( cameraEye );

    //

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( window.innerWidth, window.innerHeight );

    container.appendChild( renderer.domElement );
    /*
     renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
     renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
     renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
     */
    //

    //window.addEventListener( 'resize', onWindowResize, false );

}
/*
 function onWindowResize() {

 windowHalfX = window.innerWidth / 2;
 windowHalfY = window.innerHeight / 2;

 camera.aspect = window.innerWidth / window.innerHeight;
 camera.updateProjectionMatrix();

 renderer.setSize( window.innerWidth, window.innerHeight );

 }

 //

 function onDocumentMouseDown(event) {

 event.preventDefault();

 renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
 renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
 renderer.domElement.addEventListener( 'mouseout', onDocumentMouseOut, false );

 mouseXOnMouseDown = event.clientX - windowHalfX;
 targetRotationOnMouseDown = targetRotation;

 }

 function onDocumentMouseMove(event) {

 mouseX = event.clientX - windowHalfX;

 targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;

 }

 function onDocumentMouseUp(event) {

 renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
 renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
 renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

 }

 function onDocumentMouseOut(event) {

 renderer.domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
 renderer.domElement.removeEventListener( 'mouseup', onDocumentMouseUp, false );
 renderer.domElement.removeEventListener( 'mouseout', onDocumentMouseOut, false );

 }

 function onDocumentTouchStart(event) {

 if (event.touches.length == 1) {

 event.preventDefault();

 mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
 targetRotationOnMouseDown = targetRotation;

 }

 }

 function onDocumentTouchMove(event) {

 if (event.touches.length == 1) {

 event.preventDefault();

 mouseX = event.touches[ 0 ].pageX - windowHalfX;
 targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

 }

 }
 */
//

function animate() {

    requestAnimationFrame( animate );

    render();
    stats.update();

}

function render() {

    // Try Animate Camera Along Spline
    var time = Date.now();
    var looptime = 15 * 1000;
    var t = ( time % looptime ) / looptime;

    var pos = tube.path.getPointAt( t );
    pos.multiplyScalar( scale );

    // interpolation
    var segments = tube.tangents.length;
    var pickt = t * segments;
    var pick = Math.floor( pickt );
    var pickNext = ( pick + 1 ) % segments;

    binormal.subVectors( tube.binormals[ pickNext ], tube.binormals[ pick ] );
    binormal.multiplyScalar( pickt - pick ).add( tube.binormals[ pick ] );

    var dir = tube.path.getTangentAt( t );

    var offset = 15;

    normal.copy( binormal ).cross( dir );

    // We move on a offset on its binormal
    pos.add( normal.clone().multiplyScalar( offset ) );

    splineCamera.position = pos;
    cameraEye.position = pos;


    // Camera Orientation 1 - default look at
    // splineCamera.lookAt( lookAt );

    // Using arclength for stablization in look ahead.
    var lookAt = tube.path.getPointAt( ( t + 30 / tube.path.getLength() ) % 1 ).multiplyScalar( scale );

    // Camera Orientation 2 - up orientation via normal
    if (!lookAhead)
        lookAt.copy( pos ).add( dir );
    splineCamera.matrix.lookAt(splineCamera.position, lookAt, normal);
    splineCamera.rotation.setFromRotationMatrix( splineCamera.matrix, splineCamera.rotation.order );

    cameraHelper.update();

    parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;

    renderer.render( scene, animation === true ? splineCamera : camera );

}
</script>
</body>
</html>
